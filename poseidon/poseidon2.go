package poseidon

import (
	"errors"
	"math/big"

	"github.com/0xbow-io/go-iden3-crypto/ff"
	"github.com/0xbow-io/go-iden3-crypto/utils"
)

func stateReduce(state []*ff.Element, t, i int) *ff.Element {
	out := zero()
	for j, a := range state {
		aVal := a.ToBigIntRegular(big.NewInt(0))
		aVal.Mul(aVal, M2[t-2][j][i])
		out.Add(out, ff.NewElement().SetBigInt(aVal))
	}
	return out
}

func Normalize(aFF *ff.Element) *big.Int {
	a := aFF.ToBigInt(big.NewInt(0))
	p := ff.Modulus()
	zero := big.NewInt(0)
	if a.Cmp(zero) < 0 {
		na := zero.Sub(zero, a)
		if na.Cmp(p) >= 0 {
			na.Mod(na, p)
		}
		return big.NewInt(0).Sub(p, na)
	}
	if a.Cmp(p) >= 0 {
		a.Mod(a, p)
	}
	return a
}

func Poseidon2(inputs []*big.Int) (*big.Int, error) {
	if len(inputs) < 1 || len(inputs) > 4 {
		return nil, errors.New("incorrect number of inputs")
	}
	t := len(inputs) + 1
	nRoundsF := 8
	nRoundsP := 35

	inp := utils.BigIntArrayToElementArray(inputs)
	state := make([]*ff.Element, t)
	state[t-1] = zero()
	copy(state, inp)

	for r := 0; r < nRoundsF+nRoundsP; r++ {
		// state = state.map((a, i) => F.add(a, BigInt(C[t - 2][r * t + i])));
		for i, a := range state {
			C := C2[t-2][r*t+i]

			aVal := a.ToBigIntRegular(big.NewInt(0))
			aVal = aVal.Add(aVal, C)
			state[i] = ff.NewElement().SetBigInt(aVal)
		}

		if r < nRoundsF/2 || r >= nRoundsF/2+nRoundsP {
			for i := range state { // state = state.map(a => pow5(a))
				exp5(state[i])
			}
		} else {
			exp5(state[0])
		}

		// no matrix multiplication in the last round
		if r < nRoundsF+nRoundsP-1 {
			outputState := make([]*ff.Element, len(state))
			for i := range state {
				outputState[i] = stateReduce(state, t, i)
			}
			state = outputState
		}
	}

	return state[0].ToBigIntRegular(big.NewInt(0)), nil

}

// const assert = require("assert");
// const Scalar = require("ffjavascript").Scalar;
// const ZqField = require("ffjavascript").ZqField;
// const { unstringifyBigInts } = require("ffjavascript").utils;

// // Prime 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
// const F = new ZqField(Scalar.fromString("21888242871839275222246405745257275088548364400416034343698204186575808495617"));

// // Parameters are generated by a reference script https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/generate_parameters_grain.sage
// // Used like so: sage generate_parameters_grain.sage 1 0 254 2 8 56 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
// const { C, M } = unstringifyBigInts(require("./poseidon_constants.json"));

// // Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
// // Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
// // And rounded up to nearest integer that divides by t
// const N_ROUNDS_F = 8;
// const N_ROUNDS_P = 35;

// const pow5 = a => F.mul(a, F.square(F.square(a, a)));

// function poseidon(inputs) {
//     assert(inputs.length > 0);
//     assert(inputs.length < 5);

//     const t = inputs.length + 1;
//     const nRoundsF = N_ROUNDS_F;
//     const nRoundsP = N_ROUNDS_P;

//     let state = [...inputs.map(a => F.e(a)), F.zero];
// for (let r = 0; r < nRoundsF + nRoundsP; r++) {
//     state = state.map((a, i) => F.add(a, BigInt(C[t - 2][r * t + i])));
//     if (r < nRoundsF / 2 || r >= nRoundsF / 2 + nRoundsP) {
//         state = state.map(a => pow5(a));
//     } else {
//         state[0] = pow5(state[0]);
//     }

//     // no matrix multiplication in the last round
//     if (r < nRoundsF + nRoundsP - 1) {
//         state = state.map((_, i) =>
//             state.reduce((acc, a, j) => F.add(acc, F.mul(BigInt(M[t - 2][j][i]), a)), F.zero)
//         );
//     }
// }
// return F.normalize(state[0]);
// }

// module.exports = poseidon;
